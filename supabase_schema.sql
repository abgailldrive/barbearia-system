-- Create a table for public profiles (linked to auth.users)
create table public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  name text,
  phone text,
  role text default 'client', -- 'client', 'barber', 'admin'
  avatar_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for profiles
alter table public.profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );

-- Create a table for services
create table public.services (
  id bigint generated by default as identity primary key,
  name text not null,
  duration int not null, -- in minutes
  price decimal(10,2) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for services
alter table public.services enable row level security;

create policy "Services are viewable by everyone."
  on services for select
  using ( true );

create policy "Only admins/barbers can insert services."
  on services for insert
  with check ( 
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and (profiles.role = 'admin' or profiles.role = 'barber')
    )
  );

create policy "Only admins/barbers can update services."
  on services for update
  using ( 
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and (profiles.role = 'admin' or profiles.role = 'barber')
    )
  );

create policy "Only admins/barbers can delete services."
  on services for delete
  using ( 
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and (profiles.role = 'admin' or profiles.role = 'barber')
    )
  );


-- Create a table for appointments
create table public.appointments (
  id bigint generated by default as identity primary key,
  client_id uuid references public.profiles(id) not null,
  client_name text, -- Cache name for easier display
  service_id bigint references public.services(id),
  service_name text, -- Cache for easier display
  duration int,
  price decimal(10,2),
  date date not null,
  time time not null,
  status text default 'scheduled', -- 'scheduled', 'cancelled', 'completed'
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for appointments
alter table public.appointments enable row level security;

create policy "Users can view their own appointments."
  on appointments for select
  using ( auth.uid() = client_id );

create policy "Admins/Barbers can view all appointments."
  on appointments for select
  using ( 
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and (profiles.role = 'admin' or profiles.role = 'barber')
    )
  );

create policy "Users can insert their own appointments."
  on appointments for insert
  with check ( auth.uid() = client_id );

create policy "Users can update (cancel) their own appointments."
  on appointments for update
  using ( auth.uid() = client_id );

create policy "Admins can update any appointment."
  on appointments for update
  using ( 
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and (profiles.role = 'admin' or profiles.role = 'barber')
    )
  );

-- Function to handle new user signup (Trigger)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, name, role)
  values (new.id, new.email, new.raw_user_meta_data->>'name', 'client');
  return new;
end;
$$ language plpgsql security definer;

-- Trigger the function every time a user is created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create a secure view for checking availability (publicly accessible)
create or replace view public.busy_times as
select date, time, duration
from public.appointments
where status = 'scheduled';

-- Grant access to the view
grant select on public.busy_times to anon, authenticated;

-- Notifications Table
create table public.notifications (
  id bigint generated by default as identity primary key,
  message text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  read boolean default false,
  target_role text default 'barber' -- 'barber' or specific user_id if needed later
);

alter table public.notifications enable row level security;

create policy "Barbers can view all notifications"
  on notifications for select
  using ( 
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and (profiles.role = 'barber' or profiles.role = 'admin')
    )
  );

create policy "Barbers can update notifications (mark read)"
  on notifications for update
  using ( 
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid() and (profiles.role = 'barber' or profiles.role = 'admin')
    )
  );

-- Trigger to create notification on new appointment
create or replace function public.notify_new_appointment()
returns trigger as $$
begin
  insert into public.notifications (message, target_role)
  values (
    'Novo agendamento: ' || new.service_name || ' para ' || to_char(new.date, 'DD/MM') || ' Ã s ' || to_char(new.time, 'HH24:MI'),
    'barber'
  );
  return new;
end;
$$ language plpgsql security definer;

create trigger on_appointment_created
  after insert on public.appointments
  for each row execute procedure public.notify_new_appointment();
